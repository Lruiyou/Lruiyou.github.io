<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[二分查找算法]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分查找 适用场合（缺点）：目标数组必须是有序的 123456789101112131415161718192021222324252627282930313233343536package searchStructures;public class TestBinarySearch &#123; public static void main(String[] args) &#123; //目标数组 int[] arr = new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; TestBinarySearch ts = new TestBinarySearch(); ts.binarySearch(arr,8); &#125; public void binarySearch(int []arr,int target) &#123; int index = -1;//记录目标元素的位置 int start = 0;//记录开始元素的位置 int end = arr.length - 1;//记录结束元素的位置 int mid = (start + end)/2;//记录中点元素的位置 while(start &lt;= end) &#123; //循环查找 if(arr[mid] == target) &#123; //先判断中间元素是不是要查找的元素 index = mid; System.out.println("查找的元素的下标为："+index); break; &#125;else&#123; //中间元素不是要查找的元素 if(arr[mid] &gt; target) &#123; end = mid - 1; //把结束位置调整到中间位置的前一个位置 &#125;else &#123; start = mid + 1; //把开始位置调整到中间位置的后一个位置 &#125; mid = (start + end)/2; &#125; &#125; if(index == -1) &#123; System.out.println("没有此元素"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot全局异常处理]]></title>
    <url>%2F2019%2F08%2F08%2Fspring-boot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理拦截可以处理的逻辑错误的异常 在template目录下放error.html错误页面 12345678910111213141516171819&lt;!DOCTYPE html &lt;html lang="en" xmlns:th="http://www.thymeleaf.org" &lt;head &lt;meta charset="UTF-8" &lt;title Coder社区&lt;/title &lt;link rel="stylesheet" th:href="@&#123;/css/bootstrap.min.css&#125;" &lt;link rel="stylesheet" th:href="@&#123;/css/bootstrap-theme.min.css&#125;" &lt;link rel="stylesheet" th:href="@&#123;/css/customize.css&#125;" &lt;script th:src="@&#123;/js/jquery-3.4.1.min.js&#125;" &lt;/script &lt;script th:src="@&#123;/js/bootstrap.min.js&#125;" &lt;/script &lt;/head &lt;body &lt;div class="jumbotron" &lt;h1 出错啦! ! !&lt;/h1 &lt;p th:text="$&#123;errorMsg&#125;" &lt;/p &lt;p &lt;a class="btn btn-primary btn-lg" href="/home" role="button" 回到主页&lt;/a &lt;/p &lt;/div &lt;/body &lt;/html 自定义异常类，并且把错误信息封装成枚举类 定义一个错误信息接口 12345package com.springboot.community.exception;public interface IcustomizeErrorCode &#123; String getMessage();&#125; 错误信息的枚举类，并实现错误代码接口 1234567891011121314151617package com.springboot.community.exception;public enum CustomizeErrorCode implements IcustomizeErrorCode &#123; QUESTION_NOT_FOUND("你找的问题不在了(ง •_•)ง");//注意这个分号是一定要有的，不然会报错 private String message; CustomizeErrorCode(String message) &#123; this.message = message; &#125; @Override public String getMessage() &#123; return message; &#125;&#125; 异常类：注意要继承RuntimeException，并且从构造方法传入错误代码接口 1234567891011121314package com.springboot.community.exception;public class CustomizeException extends RuntimeException &#123; private String message; public CustomizeException(IcustomizeErrorCode errorCode) &#123; this.message = errorCode.getMessage(); &#125; public String getMessage() &#123; return message; &#125;&#125; 定义Handler并使用@ControllerAdvice和@ExceptionHandler注解，@ControllerAdvice只能处理页面级的错误 1234567891011121314151617181920212223package com.springboot.community.advice;import com.springboot.community.exception.CustomizeException;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;@ControllerAdvicepublic class CustomizeExceptionHandler &#123; @ExceptionHandler(Exception.class) ModelAndView handleControllerException(Throwable ex, Model model) &#123; if (ex instanceof CustomizeException) &#123; //出错的异常属于自定义异常，则提示自定义的出错信息 model.addAttribute("errorMsg", ex.getMessage()); &#125; else &#123; //不是自定义异常，则提示通用的出错信息 model.addAttribute("errorMsg", "服务器抽风了＞﹏＜"); &#125; return new ModelAndView("error"); &#125;&#125; 在出错处加入判断并调用自定义异常，当出错时，便会跳转到error.html页面，并提示用户出错了 12345678//示例if (questionPojo == null)&#123; throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);&#125;if (updated != 1)&#123; throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);&#125; 处理客户端或服务器出错的异常 自定义Controller并且实现ErrorController,重写getErrorPath()方法。ErrorController可以拦截所有的异常 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.springboot.community.controller;import org.springframework.boot.web.servlet.error.ErrorController;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;@Controller@RequestMapping(&#123;"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"&#125;)public class CustomizeErrorController implements ErrorController &#123; @Override public String getErrorPath() &#123; return "error"; &#125;//以下代码在BasicErrorController源码中可找到@RequestMapping(produces = &#123;"text/html"&#125;)//返回的数据格式是html页面public ModelAndView errorHtml(HttpServletRequest request, Model model) &#123;HttpStatus status = this.getStatus(request);if (status.is4xxClientError())&#123;//处理客户端异常 model.addAttribute("errorMsg","请求出错了＞﹏＜"); &#125; if (status.is5xxServerError())&#123;//处理服务器异常 model.addAttribute("errorMsg","服务器冒烟了( ╯□╰ ),请稍后再试试"); &#125; return new ModelAndView("error");&#125;private HttpStatus getStatus(HttpServletRequest request) &#123;Integer statusCode =(Integer)request.getAttribute("javax.servlet.error.status_code"); if (statusCode == null) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; else &#123; try &#123; return HttpStatus.valueOf(statusCode); &#125; catch (Exception var4) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket编程]]></title>
    <url>%2F2019%2F08%2F08%2FJava-Socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[TCP和UDP客户端向服务端发送字符串，客户端接收到字符串后输出到控制台，同时把字符串的长度发送给客户端，客户端接收到数据把长度输出到控制台，用TCP和UDP实现。 UDP实现 123456789101112131415161718192021222324252627282930package socket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;public class UDPServer &#123;public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(8888); byte[] buff = new byte[1024]; DatagramPacket packet = new DatagramPacket(buff,buff.length); socket.receive(packet); byte[] data = packet.getData(); String content = new String(data,0,packet.getLength()); System.out.println(content); byte[] sendedContent = String.valueOf(content.length()).getBytes(); DatagramPacket packetToClient = new DatagramPacket(sendedContent, sendedContent.length,packet.getAddress(),packet.getPort()); socket.send(packetToClient); socket.close(); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125; 1234567891011121314151617181920212223242526package socket;import java.io.IOException;import java.net.*;public class UDPClient &#123;public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(); byte[] buff = "Hello World".getBytes(); InetAddress address = InetAddress.getByName("127.0.0.1"); DatagramPacket packet = new DatagramPacket(buff,buff.length,address,8888); socket.send(packet);//向服务端发送数据 //接受服务端传过来的数据 byte[] data = new byte[1024]; DatagramPacket receivedPacket = new DatagramPacket(data,data.length); socket.receive(receivedPacket); String content = new String(receivedPacket.getData(),0,receivedPacket.getLength()); System.out.println(content); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125; TCP实现 1234567891011121314151617181920212223242526272829303132 package socket;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;//开启一个线程public class replyToClient extends Thread&#123;private Socket socket;public replyToClient(Socket socket) &#123; this.socket = socket;&#125;@Overridepublic void run()&#123; try &#123; InputStream is = socket.getInputStream(); OutputStream out = socket.getOutputStream(); byte[] buff = new byte[1024]; int len = is.read(buff); String receive = new String(buff,0,len); System.out.println(receive); out.write(String.valueOf(receive.length()).getBytes()); out.close(); is.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125; 123456789101112131415 package socket;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;//服务端public class tcpServer &#123;public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(8888); while (true)&#123; Socket socket = ss.accept(); new replyToClient(socket).start(); &#125;&#125;&#125; 123456789101112131415161718192021222324252627package socket;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;//客户端public class tcpClient &#123;public static void main(String[] args) &#123; try &#123; Socket st = new Socket("127.0.0.1",8888); InputStream is = st.getInputStream(); OutputStream out = st.getOutputStream(); out.write(new String("hello world").getBytes()); byte[] buff = new byte[1024]; int len = is.read(buff); System.out.println(new String(buff,0,len)); out.close(); is.close(); st.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
