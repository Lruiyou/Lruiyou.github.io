<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[RPC的简单实现]]></title>
    <url>%2F2019%2F08%2F19%2FRPC%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[RPC，即远程过程调用，客户端可以通过socket远程调用服务端的方法(接口) 用到的技术 反射 socket 动态代理 具体实现 客户端通过socket将需要请求的接口发送给服务端； 服务端将可以提供的接口注册到服务中心(通过map来保存 key：接口的名字，value：接口的实现类)； 服务端收到客户端的请求后，通过请求的接口名在服务中心的map中寻找对应的接口实现类； 找到之后，解析刚才客户端发送来的接口名，方法名，解析完毕后通过反射将该方法执行。最后将方法的结果返回给客户端。 服务端 12345package RPC.server;public interface HelloService &#123; String sayHello(String name);&#125; 12345678package RPC.server;public class HelloServiceImpl implements HelloService &#123; @Override public String sayHello(String name) &#123; return "Hi,"+name; &#125;&#125; 12345678package RPC.server;//服务中心public interface Server &#123; void start(); void stop(); //注册服务 void register(Class service,Class serviceImpl);&#125; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113package RPC.server;import java.io.IOException;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Method;import java.net.InetSocketAddress;import java.net.ServerSocket;import java.net.Socket;import java.util.HashMap;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class ServerCenter implements Server &#123; //服务端所有可供客户端访问的接口，都注册到该map中 //key:接口的名字，value：真正的实现 private static HashMap&lt;String,Class&gt; serviceRegister = new HashMap(); private static int port; //线程池：连接池中存在多个连接对象，每个连接对象都可以处理一个客户请求 private static ExecutorService executor = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors()); private static boolean isRunning = false; public ServerCenter(int port) &#123; this.port = port; &#125; /** * 开启服务 */ @Override public void start()&#123; System.out.println("start....."); ServerSocket server = null; try &#123; server = new ServerSocket(); server.bind(new InetSocketAddress(port)); &#125;catch (IOException e)&#123; e.printStackTrace(); &#125; isRunning = true; //服务已经启动 while (true)&#123; //接收客户端请求，处理请求，并返回结果，处理多个请求 //客户端每请求一次连接，则服务端从连接池获取一个线程对象去处理 //等待客户端连接 Socket socket = null; try &#123; socket = server.accept(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; executor.execute(new ServiceTask(socket)); &#125; &#125; @Override public void stop() &#123; isRunning = false; executor.shutdown(); &#125; @Override public void register(Class service,Class serviceImpl) &#123; serviceRegister.put(service.getName(), serviceImpl); &#125; private static class ServiceTask implements Runnable&#123; private Socket socket; public ServiceTask(Socket socket) &#123; this.socket = socket; &#125; @Override public void run() &#123; ObjectInputStream input = null; ObjectOutputStream output = null; try &#123; input = new ObjectInputStream(socket.getInputStream()); //ObjectInputStream对接收数据的顺序有严格要求，需要参照发送的顺序逐个接收 String serviceName = input.readUTF(); String methodName = input.readUTF(); Class[] parameterTypes = (Class[]) input.readObject();//方法参数类型 Object[] arguments = (Object[])input.readObject();//方法的参数名 Class serviceClass = serviceRegister.get(serviceName); Method method = serviceClass.getMethod(methodName, parameterTypes); //执行方法 Object result = method.invoke(serviceClass.newInstance(), arguments); //将方法执行完的结果返回给客户端 output = new ObjectOutputStream(socket.getOutputStream()); output.writeObject(result); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (output != null)&#123; output.close(); &#125; if (input!= null)&#123; input.close(); &#125; &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;&#125; 123456789101112package RPC.server;public class RPCServerTest &#123; public static void main(String[] args) &#123; new Thread(() -&gt; &#123; Server server = new ServerCenter(8888); //注册一个服务 server.register(HelloService.class, HelloServiceImpl.class); server.start(); &#125;).start(); &#125;&#125; 客户端 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061package RPC.server.client;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Proxy;import java.net.InetSocketAddress;import java.net.Socket;public class Client &#123; /** * 获取代表服务端接口的动态代理对象 * @param serviceInterface * @param addr * @param &lt;T&gt; * @return */ @SuppressWarnings("unchecked") public static &lt;T&gt; T getRemoteProxyObj(Class serviceInterface, InetSocketAddress addr)&#123; /** * 类加载器：需要代理哪个类，就将那个类的类加载器传进来 * 需要代理的对象，具备哪些方法 */ //proxy:代理的对象 method:被代理对象的方法(sayHello) args:参数列表return (T)Proxy.newProxyInstance(serviceInterface.getClassLoader(), new Class&lt;?&gt;[]&#123;serviceInterface&#125;, (proxy, method, args) -&gt; &#123; ObjectOutputStream output = null; ObjectInputStream input = null; try &#123; //客户端像服务端发送请求：请求某一个具体的接口 Socket socket = new Socket(); //socketaddress包含Ip和端口 socket.connect(addr); //用序列化流来发送 output = new ObjectOutputStream(socket.getOutputStream()); //发送接口名，方法名 output.writeUTF(serviceInterface.getName()); output.writeUTF(method.getName()); //方法参数的类型，方法参数 output.writeObject(method.getParameterTypes()); output.writeObject(args); //等待服务端处理 //接收服务端处理后的返回值 input = new ObjectInputStream(socket.getInputStream()); return input.readObject(); &#125;catch (Exception e)&#123; e.printStackTrace(); return null; &#125;finally &#123; try &#123; if (output != null) output.close(); if (input!= null) input.close(); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125;); &#125;&#125; 1234567891011121314151617package RPC.server.client;import RPC.server.HelloService;import java.net.InetSocketAddress;public class RPCClientTest &#123; public static void main(String[] args) &#123; try &#123; HelloService service = Client.getRemoteProxyObj(Class.forName("RPC.server.HelloService"), new InetSocketAddress("127.0.0.1",8888)); System.out.println(service.sayHello("gakki")); &#125; catch (ClassNotFoundException e) &#123; e.printStackTrace(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>RPC</category>
      </categories>
      <tags>
        <tag>RPC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分查找算法]]></title>
    <url>%2F2019%2F08%2F08%2F%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分查找 适用场合（缺点）：目标数组必须是有序的 123456789101112131415161718192021222324252627282930313233343536package searchStructures;public class TestBinarySearch &#123; public static void main(String[] args) &#123; //目标数组 int[] arr = new int[]&#123;1,2,3,4,5,6,7,8,9&#125;; TestBinarySearch ts = new TestBinarySearch(); ts.binarySearch(arr,8); &#125; public void binarySearch(int []arr,int target) &#123; int index = -1;//记录目标元素的位置 int start = 0;//记录开始元素的位置 int end = arr.length - 1;//记录结束元素的位置 int mid = (start + end)/2;//记录中点元素的位置 while(start &lt;= end) &#123; //循环查找 if(arr[mid] == target) &#123; //先判断中间元素是不是要查找的元素 index = mid; System.out.println("查找的元素的下标为："+index); break; &#125;else&#123; //中间元素不是要查找的元素 if(arr[mid] &gt; target) &#123; end = mid - 1; //把结束位置调整到中间位置的前一个位置 &#125;else &#123; start = mid + 1; //把开始位置调整到中间位置的后一个位置 &#125; mid = (start + end)/2; &#125; &#125; if(index == -1) &#123; System.out.println("没有此元素"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>算法</category>
      </categories>
      <tags>
        <tag>查找算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring boot全局异常处理]]></title>
    <url>%2F2019%2F08%2F08%2Fspring-boot%E5%85%A8%E5%B1%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[异常处理拦截可以处理的逻辑错误的异常 在template目录下放error.html错误页面 12345678910111213141516171819&lt;!DOCTYPE html &lt;html lang="en" xmlns:th="http://www.thymeleaf.org" &lt;head &lt;meta charset="UTF-8" &lt;title Coder社区&lt;/title &lt;link rel="stylesheet" th:href="@&#123;/css/bootstrap.min.css&#125;" &lt;link rel="stylesheet" th:href="@&#123;/css/bootstrap-theme.min.css&#125;" &lt;link rel="stylesheet" th:href="@&#123;/css/customize.css&#125;" &lt;script th:src="@&#123;/js/jquery-3.4.1.min.js&#125;" &lt;/script &lt;script th:src="@&#123;/js/bootstrap.min.js&#125;" &lt;/script &lt;/head &lt;body &lt;div class="jumbotron" &lt;h1 出错啦! ! !&lt;/h1 &lt;p th:text="$&#123;errorMsg&#125;" &lt;/p &lt;p &lt;a class="btn btn-primary btn-lg" href="/home" role="button" 回到主页&lt;/a &lt;/p &lt;/div &lt;/body &lt;/html 自定义异常类，并且把错误信息封装成枚举类 定义一个错误信息接口 12345package com.springboot.community.exception;public interface IcustomizeErrorCode &#123; String getMessage();&#125; 错误信息的枚举类，并实现错误代码接口 1234567891011121314151617package com.springboot.community.exception;public enum CustomizeErrorCode implements IcustomizeErrorCode &#123; QUESTION_NOT_FOUND("你找的问题不在了(ง •_•)ง");//注意这个分号是一定要有的，不然会报错 private String message; CustomizeErrorCode(String message) &#123; this.message = message; &#125; @Override public String getMessage() &#123; return message; &#125;&#125; 异常类：注意要继承RuntimeException，并且从构造方法传入错误代码接口 1234567891011121314package com.springboot.community.exception;public class CustomizeException extends RuntimeException &#123; private String message; public CustomizeException(IcustomizeErrorCode errorCode) &#123; this.message = errorCode.getMessage(); &#125; public String getMessage() &#123; return message; &#125;&#125; 定义Handler并使用@ControllerAdvice和@ExceptionHandler注解，@ControllerAdvice只能处理页面级的错误 1234567891011121314151617181920212223package com.springboot.community.advice;import com.springboot.community.exception.CustomizeException;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.ControllerAdvice;import org.springframework.web.bind.annotation.ExceptionHandler;import org.springframework.web.servlet.ModelAndView;@ControllerAdvicepublic class CustomizeExceptionHandler &#123; @ExceptionHandler(Exception.class) ModelAndView handleControllerException(Throwable ex, Model model) &#123; if (ex instanceof CustomizeException) &#123; //出错的异常属于自定义异常，则提示自定义的出错信息 model.addAttribute("errorMsg", ex.getMessage()); &#125; else &#123; //不是自定义异常，则提示通用的出错信息 model.addAttribute("errorMsg", "服务器抽风了＞﹏＜"); &#125; return new ModelAndView("error"); &#125;&#125; 在出错处加入判断并调用自定义异常，当出错时，便会跳转到error.html页面，并提示用户出错了 12345678//示例if (questionPojo == null)&#123; throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);&#125;if (updated != 1)&#123; throw new CustomizeException(CustomizeErrorCode.QUESTION_NOT_FOUND);&#125; 处理客户端或服务器出错的异常 自定义Controller并且实现ErrorController,重写getErrorPath()方法。ErrorController可以拦截所有的异常 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.springboot.community.controller;import org.springframework.boot.web.servlet.error.ErrorController;import org.springframework.http.HttpStatus;import org.springframework.stereotype.Controller;import org.springframework.ui.Model;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.servlet.ModelAndView;import javax.servlet.http.HttpServletRequest;@Controller@RequestMapping(&#123;"$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;"&#125;)public class CustomizeErrorController implements ErrorController &#123; @Override public String getErrorPath() &#123; return "error"; &#125;//以下代码在BasicErrorController源码中可找到@RequestMapping(produces = &#123;"text/html"&#125;)//返回的数据格式是html页面public ModelAndView errorHtml(HttpServletRequest request, Model model) &#123;HttpStatus status = this.getStatus(request);if (status.is4xxClientError())&#123;//处理客户端异常 model.addAttribute("errorMsg","请求出错了＞﹏＜"); &#125; if (status.is5xxServerError())&#123;//处理服务器异常 model.addAttribute("errorMsg","服务器冒烟了( ╯□╰ ),请稍后再试试"); &#125; return new ModelAndView("error");&#125;private HttpStatus getStatus(HttpServletRequest request) &#123;Integer statusCode =(Integer)request.getAttribute("javax.servlet.error.status_code"); if (statusCode == null) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; else &#123; try &#123; return HttpStatus.valueOf(statusCode); &#125; catch (Exception var4) &#123; return HttpStatus.INTERNAL_SERVER_ERROR; &#125; &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java</category>
        <category>异常处理</category>
      </categories>
      <tags>
        <tag>spring boot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java Socket编程]]></title>
    <url>%2F2019%2F08%2F08%2FJava-Socket%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[TCP和UDP客户端向服务端发送字符串，客户端接收到字符串后输出到控制台，同时把字符串的长度发送给客户端，客户端接收到数据把长度输出到控制台，用TCP和UDP实现。 UDP实现 123456789101112131415161718192021222324252627282930package socket;import java.io.IOException;import java.net.DatagramPacket;import java.net.DatagramSocket;import java.net.SocketException;public class UDPServer &#123;public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(8888); byte[] buff = new byte[1024]; DatagramPacket packet = new DatagramPacket(buff,buff.length); socket.receive(packet); byte[] data = packet.getData(); String content = new String(data,0,packet.getLength()); System.out.println(content); byte[] sendedContent = String.valueOf(content.length()).getBytes(); DatagramPacket packetToClient = new DatagramPacket(sendedContent, sendedContent.length,packet.getAddress(),packet.getPort()); socket.send(packetToClient); socket.close(); &#125; catch (SocketException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125; 1234567891011121314151617181920212223242526package socket;import java.io.IOException;import java.net.*;public class UDPClient &#123;public static void main(String[] args) &#123; try &#123; DatagramSocket socket = new DatagramSocket(); byte[] buff = "Hello World".getBytes(); InetAddress address = InetAddress.getByName("127.0.0.1"); DatagramPacket packet = new DatagramPacket(buff,buff.length,address,8888); socket.send(packet);//向服务端发送数据 //接受服务端传过来的数据 byte[] data = new byte[1024]; DatagramPacket receivedPacket = new DatagramPacket(data,data.length); socket.receive(receivedPacket); String content = new String(receivedPacket.getData(),0,receivedPacket.getLength()); System.out.println(content); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125; TCP实现 1234567891011121314151617181920212223242526272829303132 package socket;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;//开启一个线程public class replyToClient extends Thread&#123;private Socket socket;public replyToClient(Socket socket) &#123; this.socket = socket;&#125;@Overridepublic void run()&#123; try &#123; InputStream is = socket.getInputStream(); OutputStream out = socket.getOutputStream(); byte[] buff = new byte[1024]; int len = is.read(buff); String receive = new String(buff,0,len); System.out.println(receive); out.write(String.valueOf(receive.length()).getBytes()); out.close(); is.close(); socket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125; 123456789101112131415 package socket;import java.io.IOException;import java.net.ServerSocket;import java.net.Socket;//服务端public class tcpServer &#123;public static void main(String[] args) throws IOException &#123; ServerSocket ss = new ServerSocket(8888); while (true)&#123; Socket socket = ss.accept(); new replyToClient(socket).start(); &#125;&#125;&#125; 123456789101112131415161718192021222324252627package socket;import java.io.IOException;import java.io.InputStream;import java.io.OutputStream;import java.net.Socket;//客户端public class tcpClient &#123;public static void main(String[] args) &#123; try &#123; Socket st = new Socket("127.0.0.1",8888); InputStream is = st.getInputStream(); OutputStream out = st.getOutputStream(); out.write(new String("hello world").getBytes()); byte[] buff = new byte[1024]; int len = is.read(buff); System.out.println(new String(buff,0,len)); out.close(); is.close(); st.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;&#125;&#125;]]></content>
      <categories>
        <category>Java</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>网络编程</tag>
      </tags>
  </entry>
</search>
